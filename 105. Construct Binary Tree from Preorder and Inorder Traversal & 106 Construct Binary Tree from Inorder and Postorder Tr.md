#  105. Construct Binary Tree from Preorder and Inorder Traversal & 106 Construct Binary Tree from Inorder and Postorder Traversal

- Description of these two questions

  > Given inorder and postorder traversal of a tree, construct the binary tree.
  >
  > **Note:**
  > You may assume that duplicates do not exist in the tree.
  >
  > For example, given
  >
  > ```
  > inorder = [9,3,15,20,7]
  > postorder = [9,15,7,20,3]
  > ```
  >
  > Return the following binary tree:
  >
  > ```
  >     3
  >    / \
  >   9  20
  >     /  \
  >    15   7
  > ```
  >
  > ----------------------------------------------------------------------------------------------------------------------------------------------
  >
  > Given preorder and inorder traversal of a tree, construct the binary tree.
  >
  > **Note:**
  > You may assume that duplicates do not exist in the tree.
  >
  > For example, given
  >
  > ```
  > preorder = [3,9,20,15,7]
  > inorder = [9,3,15,20,7]
  > ```
  >
  > Return the following binary tree:
  >
  > ```
  >     3
  >    / \
  >   9  20
  >     /  \
  >    15   7
  > ```

- Solution

  > 1. The reason why I put these two questions together is that they have the same template. 
  >
  > normal solution of 105 and 106. The key is finding the index of the root. Then use this index and the length of the inorder list.
  >
  > ```pyton3
  > class Solution:
  >     def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
  >         if not preorder: return None
  >         root_val = preorder[0]
  >         root = TreeNode(root_val)
  >         left_inorder = inorder[:inorder.index(root_val)]
  >         right_inorder = inorder[inorder.index(root_val) + 1:]
  >         left_preorder = preorder[1:len(left_inorder) + 1]
  >         right_preorder = preorder[len(left_inorder) + 1:]
  >         root.left = self.buildTree(left_preorder, left_inorder)
  >         root.right = self.buildTree(right_preorder, right_inorder)
  >         return root
  > class Solution:
  >     def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
  >         if not inorder: return None
  >         root_val = postorder[-1]
  >         root = TreeNode(root_val)
  >         index = inorder.index(root_val)
  >         left_inorder = inorder[:index]
  >         right_inorder = inorder[index + 1:]
  >         len_of_left_tree = index
  >         left_postorder = postorder[:index]
  >         right_postorder = postorder[index:-1]
  >         root.left = self.buildTree(left_inorder, left_postorder)
  >         root.right = self.buildTree(right_inorder, right_postorder)
  >         return root
  > ```
  >
  > 2. Besides, I found a very smart solution without coping with the segmentation of the inorder list using the pop function. When it comes to the root.right, the elements that should be in the left-tree have already been popped out!  Two subtle differences of these two solution are the pop position(the root is located at the head of the preorder list and the tail of the postorder list) and the recursive order(In the preorder, left first and then right. In the postorder, right first and then left.) Take my knees. Here is the reference: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34579/Python-short-recursive-solution.
  >
  >    The avatar of this guy is so cute!
  >
  >    ```python3
  >    class Solution:
  >        def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
  >            if inorder:
  >                root_val = preorder.pop(0)## key difference 1
  >                root = TreeNode(root_val)
  >                index = inorder.index(root_val)
  >                root.left = self.buildTree(preorder, inorder[:index])## pay attention to the recursive order.
  >                root.right = self.buildTree(preorder, inorder[index + 1:])
  >                return root
  >    class Solution:
  >        def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
  >            if inorder:
  >                root_val = postorder.pop()
  >                index = inorder.index(root_val)
  >                root = TreeNode(root_val)
  >                root.right = self.buildTree(inorder[index + 1:], postorder)
  >                root.left = self.buildTree(inorder[:index], postorder)
  >                return root
  >    ```
  >
  >    